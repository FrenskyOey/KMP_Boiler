# Cursor/Antigravity Rules for KMP Feature-First Architecture

## Project Context
This is a Kotlin Multiplatform (KMP) project with **Feature-First Modular Architecture**. Each feature is self-contained with its own data, domain, and DI layers.

## Feature-First Architecture Rules (CRITICAL)

### Feature Structure
```
shared/src/commonMain/kotlin/
├── core/               # Shared utilities ONLY
│   ├── data/
│   ├── domain/
│   ├── di/
│   └── util/
└── feature/            # Feature modules
    ├── news/
    │   ├── data/
    │   ├── domain/
    │   └── di/
    └── settings/
        ├── data/
        ├── domain/
        └── di/
```

### CRITICAL Dependency Rules

**✅ ALLOWED:**
- Features can depend on `core/`
- Features can depend on external libraries
- UI layer can depend on any feature

**❌ FORBIDDEN:**
- Features CANNOT depend on other features
- Features CANNOT import from other features
- Features CANNOT share code directly

**Example:**
```kotlin
// ✅ CORRECT - Feature depends on core
import com.example.core.domain.model.Result
import com.example.feature.news.domain.model.NewsFeed

// ❌ WRONG - Feature depends on another feature
import com.example.feature.settings.domain.model.AppSettings // NO!
```

### When Features Need to Communicate

If features need to share data or communicate:

**Option 1: Move to Core**
```kotlin
// If multiple features need it, move to core/domain/model/
core/domain/model/User.kt
```

**Option 2: Use Events/Messages**
```kotlin
// Create event bus in core
core/domain/event/AppEvent.kt
```

**Option 3: Through UI/Navigation**
```kotlin
// Features communicate through navigation with results
navController.previousBackStackEntry?.savedStateHandle?.set("result", data)
```

## Layer Separation Within Features

### Each Feature Must Have:

1. **data/** - Data layer
   - `remote/` - API services, DTOs
   - `local/` - DAOs, Entities  
   - `repository/` - Repository implementations
   - `mapper/` - DTO ↔ Domain mappers

2. **domain/** - Business logic
   - `model/` - Domain models (pure Kotlin)
   - `repository/` - Repository interfaces
   - `usecase/` - Business logic

3. **di/** - Dependency injection
   - One Koin module per feature

### Dependency Direction Within Feature
```
data → domain ← (nothing)
```
- `data/` depends on `domain/`
- `domain/` depends on NOTHING (except core)

## Code Organization Rules

### Naming Conventions

**Features:**
- Package: `feature.[feature_name]` (e.g., `feature.news`, `feature.settings`)
- Lowercase, singular preferred

**Classes:**
- PascalCase: `NewsFeedRepository`
- Feature prefix optional but consistent

**Files:**
- Use cases: `[Action][Entity]UseCase.kt`
- Repositories: `[Entity]Repository.kt` (interface), `[Entity]RepositoryImpl.kt` (impl)
- DTOs: `[Entity]Dto.kt`
- Entities: `[Entity]Entity.kt`
- Modules: `[Feature]Module.kt`

### File Location Rules

```kotlin
// ✅ CORRECT - Shared utilities in core
core/data/remote/util/ApiErrorHandler.kt
core/domain/model/Result.kt
core/domain/model/AppException.kt

// ✅ CORRECT - Feature-specific in feature
feature/news/data/remote/api/NewsApiService.kt
feature/news/domain/model/NewsFeed.kt
feature/news/di/NewsModule.kt

// ❌ WRONG - Feature-specific in core
core/domain/model/NewsFeed.kt  // Should be in feature/news/

// ❌ WRONG - Shared utility in feature
feature/news/data/util/ApiErrorHandler.kt  // Should be in core/
```

## Core Module Rules

### What Goes in Core:

**✅ Put in Core:**
- Result wrapper
- AppException types
- API error handling
- JSON serialization config
- Mapper interface
- PaginatedData model
- Database instance
- PreferencesManager interface
- Date formatting utilities
- Network configuration
- Logging utilities

**❌ Don't Put in Core:**
- Feature-specific models
- Feature-specific DTOs
- Feature-specific use cases
- Feature-specific repositories
- Feature business logic

### Core Module Structure

```kotlin
core/
├── data/
│   ├── remote/
│   │   ├── util/              # API utilities
│   │   └── base/              # Base API classes
│   ├── local/
│   │   ├── database/          # Room database
│   │   └── preferences/       # DataStore
│   └── mapper/                # Mapper interface
├── domain/
│   └── model/                 # Shared domain models
├── di/                        # Core DI modules
└── util/                      # Utilities
```

## Dependency Injection Rules

### Feature Modules

```kotlin
// ✅ CORRECT - One module per feature
val newsModule = module {
    // API
    single<NewsApiService> { NewsApiServiceImpl(get(), get(), get()) }
    
    // DAO
    single { get<AppDatabase>().newsFeedDao() }
    
    // Repository
    single<NewsFeedRepository> { NewsFeedRepositoryImpl(get(), get(), get()) }
    
    // Use Cases
    factory { GetNewsFeedUseCase(get()) }
    factory { GetNewsDetailUseCase(get()) }
}

// ❌ WRONG - Multiple features in one module
val sharedModule = module {
    single<NewsApiService> { NewsApiServiceImpl(get()) }
    single<SettingsRepository> { SettingsRepositoryImpl(get()) }
}
```

### Module Organization

```kotlin
// Application initialization
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@MyApp)
            modules(
                // Core modules first
                coreNetworkModule,
                coreDatabaseModule,
                corePreferencesModule,
                
                // Feature modules
                newsModule,
                settingsModule,
                
                // App module last
                appModule
            )
        }
    }
}
```

## Android UI Organization

### Feature-Based UI Structure

```kotlin
composeApp/src/main/kotlin/
├── core/
│   ├── theme/                 # Shared theme
│   ├── navigation/            # Navigation setup
│   └── components/            # Shared components
└── feature/
    ├── news/
    │   ├── list/
    │   │   ├── NewsFeedScreen.kt
    │   │   ├── NewsFeedViewModel.kt
    │   │   └── components/
    │   └── detail/
    │       ├── NewsDetailScreen.kt
    │       └── NewsDetailViewModel.kt
    └── settings/
        ├── SettingsScreen.kt
        ├── SettingsViewModel.kt
        └── components/
```

### UI Rules

```kotlin
// ✅ CORRECT - ViewModel uses use cases from same feature
class NewsFeedViewModel(
    private val getNewsFeedUseCase: GetNewsFeedUseCase,
    private val refreshNewsFeedUseCase: RefreshNewsFeedUseCase
) : ViewModel()

// ❌ WRONG - ViewModel uses use cases from different feature
class NewsFeedViewModel(
    private val getNewsFeedUseCase: GetNewsFeedUseCase,
    private val getSettingsUseCase: GetSettingsUseCase  // WRONG!
) : ViewModel()
```

## Navigation Between Features

```kotlin
// ✅ CORRECT - Navigation at app level
NavHost(navController, startDestination = Screen.NewsFeedList.route) {
    // News feature screens
    composable(Screen.NewsFeedList.route) {
        NewsFeedScreen(
            onNewsItemClick = { id -> navController.navigate(Screen.NewsDetail.createRoute(id)) },
            onSettingsClick = { navController.navigate(Screen.Settings.route) }
        )
    }
    
    // Settings feature screens
    composable(Screen.Settings.route) {
        SettingsScreen(
            onBackClick = { navController.popBackStack() }
        )
    }
}
```

## Error Handling Rules

### Use Core Error Types

```kotlin
// ✅ CORRECT - Feature uses core error types
suspend fun getNewsFeed(): Result<List<NewsFeed>> {
    return try {
        val data = apiService.getNewsFeed()
        Result.Success(data)
    } catch (e: Exception) {
        Result.Error(ApiErrorHandler.handleError(e))  // From core
    }
}

// ❌ WRONG - Feature creates own error types
sealed class NewsException : Exception()  // Should use core AppException
```

## Testing Rules

### Test Structure

```kotlin
// Tests mirror the source structure
shared/src/commonTest/kotlin/
├── core/
│   └── data/
│       └── util/
│           └── ApiErrorHandlerTest.kt
└── feature/
    ├── news/
    │   ├── domain/
    │   │   └── usecase/
    │   │       └── GetNewsFeedUseCaseTest.kt
    │   └── data/
    │       └── repository/
    │           └── NewsFeedRepositoryImplTest.kt
    └── settings/
        └── domain/
            └── usecase/
                └── GetSettingsUseCaseTest.kt
```

### Test Isolation

```kotlin
// ✅ CORRECT - Test only the feature being tested
class GetNewsFeedUseCaseTest {
    private lateinit var fakeRepository: FakeNewsFeedRepository
    private lateinit var useCase: GetNewsFeedUseCase
    
    @Before
    fun setup() {
        fakeRepository = FakeNewsFeedRepository()
        useCase = GetNewsFeedUseCase(fakeRepository)
    }
}

// ❌ WRONG - Test depends on another feature
class GetNewsFeedUseCaseTest {
    private lateinit var settingsRepository: SettingsRepository  // WRONG!
}
```

## Adding New Features

### Template for New Feature

```
1. Create feature directory:
   shared/src/commonMain/kotlin/feature/[feature_name]/

2. Create structure:
   feature/[feature_name]/
   ├── data/
   │   ├── remote/ (if needed)
   │   ├── local/ (if needed)
   │   └── repository/
   ├── domain/
   │   ├── model/
   │   ├── repository/
   │   └── usecase/
   └── di/
       └── [Feature]Module.kt

3. Implement domain layer first:
   - Create domain models
   - Define repository interface
   - Create use cases

4. Implement data layer:
   - Create DTOs/Entities
   - Implement repository
   - Create mappers

5. Create DI module:
   - Wire all dependencies

6. Add to app:
   - Add module to Koin initialization
   - Create UI screens
   - Add to navigation

7. VERIFY:
   - Feature doesn't depend on other features
   - Only uses core for shared utilities
   - Has its own Koin module
```

## Code Review Checklist

Before accepting code, verify:

### Architecture:
- [ ] Features don't depend on each other
- [ ] Features only use core for shared utilities
- [ ] Each feature has data/domain/di structure
- [ ] Shared utilities are in core, not features
- [ ] Each feature has its own Koin module

### Code Quality:
- [ ] Follows Clean Architecture within feature
- [ ] Uses dependency injection (Koin)
- [ ] Has proper error handling with core Result
- [ ] Maps between DTOs/Entities and Domain models
- [ ] Uses suspend functions for async operations
- [ ] Has proper state management
- [ ] Follows Kotlin coding conventions
- [ ] No hardcoded values
- [ ] Uses theme helpers
- [ ] Has appropriate documentation

### Feature Isolation:
- [ ] No imports from other features
- [ ] All dependencies injected via Koin
- [ ] Can be removed without breaking other features
- [ ] Has its own tests

## When to Push Back on User Requests

### ALWAYS Refuse:
- Making features depend on each other
- Putting feature-specific code in core
- Putting shared utilities in features
- Mixing multiple features in one module
- Violating Clean Architecture within features
- Not using dependency injection

### SUGGEST Alternatives:
- "Move to core" - If code is used by multiple features
- "Create event bus" - If features need to communicate
- "Pass via navigation" - If features need to share data
- "Separate module" - If feature is growing too large

## Performance Considerations

### Feature Loading
```kotlin
// ✅ CORRECT - Lazy load feature modules
val newsModule = module {
    // Only load when feature is accessed
}

// Features can be enabled/disabled via feature flags
if (BuildConfig.FEATURE_NEWS_ENABLED) {
    modules(newsModule)
}
```

## Documentation Standards

Each feature should have:

```kotlin
/**
 * News Feature
 * 
 * Handles news feed display, pagination, and detail viewing.
 * 
 * Dependencies:
 * - core.data.remote for API utilities
 * - core.domain.model for Result wrapper
 * - core.data.local for database
 * 
 * Provides:
 * - News feed list with pagination
 * - News detail view
 * - Offline caching
 */
package com.example.feature.news
```

---

**Remember: Feature-first architecture is about building scalable, maintainable apps where features are isolated, self-contained, and can evolve independently. These rules ensure that architecture is preserved.**
